#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/video/background_segm.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include <iostream>
using namespace cv;
using namespace std;

//Define variables and constants
#define radius 3
#define thickness 2
// After how many loops does it take a picture of your hand, assumes hand is there after this many loops
#define loopCountSeconds 55
//how many loops does it take average for
#define averageLoopCount 20

// Range of values for color checking
#define firstRange 40
#define secondRange 40
#define thirdRange 40

// Blur pixel radius
#define blurRadius 7

//points where the data will be taken
vector<Point> points;
// to add all the colors from the above points
Scalar averageColor;
void initializePoints(Mat frame)
{
    // to quickly move whole figure
    int xOffset = 100;
    int yOffset = 0;
    // points vaguely in the shape of a hand
    points.push_back(Point(frame.cols/3 + xOffset, frame.rows/6 + yOffset));
    points.push_back(Point(frame.cols/4 + xOffset, frame.rows/2 + yOffset));
    points.push_back(Point(frame.cols/3 + xOffset, frame.rows/1.5 + yOffset));
    points.push_back(Point(frame.cols/2 + xOffset, frame.rows/2 + yOffset));
    points.push_back(Point(frame.cols/2.5 + xOffset, frame.rows/2.5 + yOffset));
    points.push_back(Point(frame.cols/2 + xOffset, frame.rows/1.5 + yOffset));
    points.push_back(Point(frame.cols/2.5 + xOffset, frame.rows/1.8 + yOffset));
}

void drawPoints(Mat frame, Scalar color)
{
    // Print instructions on screen
    string imgText = string("Cover rectangles with palm");
    int fontFace = FONT_HERSHEY_PLAIN;
    putText(frame,imgText,Point(frame.cols/2, frame.rows/10),fontFace, 1.2f,Scalar(200,0,0),2);

    for(auto iter=points.begin();iter!=points.end();++iter)
    {
        circle(frame, *iter, radius, color, thickness);        
    }  
}

Scalar getAverageColor(Mat frame)
{
    // Set the regions of interest with the points
    int i=0;
    // total colours for final average
    long r=0, g=0, b=0;
    Scalar color;
    for(auto iter=points.begin();iter!=points.end();++iter,i++)
    {
        // Create a rectangle with with each of the points, enclosing the circle
        Rect rect(iter->x - radius, iter->y - radius, radius * 2,radius * 2);
        // Create regions of interest from the frame, and then calculate its mean
        color=mean(frame(rect));
        // Add bgr to total
        b+=color[0];
        r+=color[1];
        g+=color[2];
    }
    Scalar averageColor(b/i,r/i,g/i);
    return averageColor;
}

long normalize(long color)
{
    if (color<0)
        return 0;
    if (color>255)
        return 255;
    return color;
}

Mat filterColor(Mat frame, Scalar averageColor)
{
    Mat threshold;
    Scalar low = Scalar(normalize(averageColor[0] - firstRange), normalize(averageColor[1] - secondRange), normalize(averageColor[2] - thirdRange));
    Scalar high = Scalar(normalize(averageColor[0] + firstRange), normalize(averageColor[1] + secondRange), normalize(averageColor[2] + thirdRange));
    // cout<<low<<high<<endl;
    inRange(frame, low, high, threshold);
    // Add a blur for better filter
    medianBlur(threshold, threshold, blurRadius);
    return threshold;
}

int main(int argc, char const *argv[])
{
    // open the default camera
    VideoCapture cap(0); 
    // check if we succeeded
    if(!cap.isOpened())  
        return -1;

    BackgroundSubtractorMOG2 mog2;

    Mat edges;
    Mat frame;
    Mat filtered;
    //foreground mask generated by MOG method
    Mat fgMaskMOG; 

    // get sample frame and initialise points with it
    cap >> frame; 
    initializePoints(frame);

    bool scanned = false;
    for(int loopcount=0;;loopcount++)
    {
        // get a new frame from camera
        cap >> frame; 
        // flip the image horizonatally to get mirror effect
        flip(frame,frame,1);
        // cvtColor(frame, frame, CV_BGR2HLS);
        Scalar tempAverage;
        if (!scanned && loopcount > loopCountSeconds){
            int j;
            for(j=0;j<averageLoopCount; ++j)
            {
                tempAverage=getAverageColor(frame);
                averageColor+=tempAverage;
            }
            averageColor/=j;
            cout<<averageColor<<endl;
            scanned=!scanned;
        }
        if (!scanned)
            // draw points in blue
            drawPoints(frame, Scalar(255,0,0));
        if(scanned){
            frame=filterColor(frame, averageColor);

        }
        // mog2(frame, fgMaskMOG);
        // imshow("fram", fgMaskMOG);
        imshow("frame", frame);
        if(waitKey(30) >= 0) break; //exit on some key
    }

    
    return 0;
}

